%**************************************************************************
% Func_Orientation_Tensor_RH.m
%**************************************************************************
%
% Function defining a weighted symmetric orientation tensor from
% vectors of crystal directions in (pole figure) sample co-ordinates
% added functionality for rotating the Eigen-vectors reference frame
%
% By David Mainprice
%
% Last revised 2/10/2017
% Tested with MTEX 4.5.1
%
% * Eigen-values normalize to E_values(1)+E_values(2)+E_values(3) = 1
% * Eigen-vectors defined as a right-handed set
% * Export rotation matrix R and its Bunge Euler angles
%
% Orientation Tensor for axial data is calculated using very efficient
% numerical method of Bachmann et al. (2010) using the multiplication
% of the column vector by a row vector of the scatter data (equation 12)
% to form the covariance matrix known as the Orientation Tensor.
%
% Bachmann,F., Hielscher,R., Jupp,P.E., Pantleon,W., Schaeben,H., Wegert,E.
% (2010) Inferential statistics of electron backscatter diffraction data
% from within individual crystalline grains.
% Journal of Applied Crystallography, 43, 1338-1355.
%
% Input
%
% v - @vector3d (vectors of crystal directions in sample co-ordinates)
%
% typically generated by the MTEX statments
% Extract orientations of Forsterite (o) from ebsd object
% o = ebsd('Forsterite').orientations
% Generate vectors (v) of crystal directions (hkl or uvw) e.g. (100)
% in sample co-ordinates as MTEX vector3d 
% v = o * Miller(1,0,0,'uvw',ebsd('Forsterite').cs);
% get Orientation tensor (OT), eigen-values and vectors
% [OT,E_values,E_vec1,E_vec2,E_vec3,rot] = Func_Orientation_Tensor_RH(v)
%
% Output
%
%  OT(3,3) - 3 by 3 weighted symmetric orientation tensor
%  E_value(3) - 3 eigen-values in descending order of magnitude
%  E_vec1(3)  - 
%  E_vec2(3)  - eigen-vectors as MTEX 3dvectors
%  E_vec3(3)  -
%  rot        - MTEX command for rotation defined using Euler angles
% Notes
%
%**************************************************************************
% Use for annotating pole figures using Eigen-vectors
%************************************************************************** 
% Calculate the [010] vector directions in pole figure reference frame
% v010 = ebsd('Forsterite').orientations * Miller(0,1,0,ebsd('Forsterite').CS,'uvw');
% Calculate orienation tensor, Eigen-values & -vectors and MTEX rotation
% [OT,E_values,E_vec1,E_vec2,E_vec3,rot] = Func_Orientation_Tensor_RH(v010);
% plot figure of original orientation
% figure
% plot(v010,'antipodal')
% annotate([E_vec1,E_vec2,E_vec3],'label',{'E1','E2','E3'},'BackgroundColor','w')
%
%**************************************************************************
% Use for rotation
%**************************************************************************
% Calculate the [010] vector directions in pole figure reference frame
% v010 = ebsd('Forsterite').orientations * Miller(0,1,0,ebsd('Forsterite').CS,'uvw');
% Calculate orienation tensor, Eigen-values & -vectors and MTEX rotation
% [OT,E_values,E_vec1,E_vec2,E_vec3,rot] = Func_Orientation_Tensor_RH(v010);
% plot figure of original orientation
% figure
% plot(v010,'antipodal')
% annotate([E_vec1,E_vec2,E_vec3],'label',{'E1_o','E2_o','E3_o'},'BackgroundColor','w')
% Rotate ebsd and v010 using R_mtex
% rotate ebsd data
% ebsd_R = rotate(ebsd,rot)
% rotated v010
% v010_R = ebsd_R('Forsterite').orientations * Miller(0,1,0,ebsd('Forsterite').CS,'uvw');
% Calculated OT etc in rotated position
% [OT_R,E_values_R,E_vec1_R,E_vec2_R,E_vec3_R,rot] = Func_Orientation_Tensor_RH(v010_R);
% plot figure rotated orientation
% figure
% plot(v010_R,'antipodal')
% annotate([E_vec1_R,E_vec2_R,E_vec3_R],'label',{'E1_r','E2_r','E3_r'},'BackgroundColor','w')
%***********************************************************************
% Use of function
% [OT,E_values,E_vec1,E_vec2,E_vec3,rot] = Func_Oriention_Matrix(v)
%
function [OT,E_values,E_vec1,E_vec2,E_vec3,rot] = Func_Orientation_Tensor_RH(v)
% Set up a covariance matrix
[x,y,z] = double(v);
% OT = weighted multipication of the column vector by a row vector
%      of the scatter data
OT = 1./numel(x)*[x,y,z]'*[x,y,z];
%**************************************************************************
% Eigen-values and -vectors of OT matrix
%**************************************************************************
[Vec,Diagonal] = eig(OT);
% Eigen-values : conversion diagonal matrix to vector
E_values = diag(Diagonal);
%**************************************************************************
% Normalize to E_values(1)+E_values(2)+E_values(3) = 1
%**************************************************************************
NORM=E_values(1)+E_values(2)+E_values(3);
E_values(1) = E_values(1)/NORM;
E_values(2) = E_values(2)/NORM;
E_values(3) = E_values(3)/NORM;
% Sort Eigen-values in descending order
[E_values,index] = sort(E_values,'descend');
% Sort Eigen-vectors and convert Eigen-vectors to
% MTEX specimen co-ordinates vector3d
E_vec1 = vector3d(Vec(:,index(1)));
E_vec2 = vector3d(Vec(:,index(2)));
E_vec3 = vector3d(Vec(:,index(3)));
%**************************************************************************
% Make the Eigen-vectors a right-handed set
%**************************************************************************
% so that vector cross product is [1 x 2] = 3
% and the triplet {1,2,[1 x 2]} from an ordered right-handed "basis" in R3
E_vec3 = cross(E_vec1,E_vec2);
% triple cross product [1 x 2].3 >0 positive for right-handed frame
%Test = dot(cross(E_vec1,E_vec2),E_vec3);
%**************************************************************************
% Set-up rotation matrix R
%**************************************************************************
R = [E_vec1.xyz;E_vec2.xyz;E_vec3.xyz];
% MTEX rotation command
rot = rotation('matrix',R);
end
%
% End of function
%
